<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Orienteering Races Map</title>
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  
  <!-- PapaParse for CSV -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- noUiSlider (double-handle range slider) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.js"></script>

  <style>
    :root {
      --bg: #0b0d10;
      --panel: #14171c;
      --muted: #9aa4b2;
      --text: #e6edf3;
      --accent: #4aa3ff;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    .controls { display:flex; gap: 1rem; align-items:center; padding: .75rem 1rem; background: var(--panel); box-shadow: 0 2px 10px rgba(0,0,0,.25); position: sticky; top: 0; z-index: 1000; }
    .controls h1 { font-size: 1rem; margin: 0 .5rem 0 0; font-weight: 600; color: var(--text); white-space: nowrap; }
    .slider-wrap { flex: 1 1 auto; }
    #slider { margin: .25rem 0; }
    .date-labels { display:flex; justify-content: space-between; font-size:.85rem; color: var(--muted); }
    .pill { background: rgba(74,163,255,.12); color: var(--accent); padding: .25rem .5rem; border-radius: 999px; font-size: .8rem; }
    .count { white-space: nowrap; }
    #map { height: calc(100vh - 64px); width: 100%; }

    /* Tooltip (legacy) */
    .leaflet-tooltip.zavod-tip { background: #111418; color: var(--text); border: 1px solid #2a2f36; box-shadow: 0 6px 18px rgba(0,0,0,.45); border-radius: .5rem; padding: .5rem .6rem; }
    .tip-title { font-weight: 600; margin-bottom: .15rem; }
    .tip-place { color: var(--muted); font-size: .9rem; margin-bottom: .2rem; }
    .tip-link a { color: var(--accent); text-decoration: none; }
    .tip-link a:hover { text-decoration: underline; }

    /* Marker style via DivIcon */
    .race-pin { width: 14px; height: 14px; border-radius: 50%; background: #4aa3ff; border: 2px solid #e6edf3; box-shadow: 0 0 0 2px rgba(74,163,255,.25), 0 6px 14px rgba(0,0,0,.35); }

    /* Popup content styling */
    .leaflet-popup-content { margin: 8px 10px; }
    .leaflet-popup-content .tip-title { font-weight: 600; margin-bottom: .15rem; }
    .leaflet-popup-content .tip-place { color: var(--muted); font-size: .9rem; margin-bottom: .2rem; }
    .leaflet-popup-content .tip-link a { color: var(--accent); text-decoration: none; }
    .leaflet-popup-content .tip-link a:hover { text-decoration: underline; }

    /* Test panel */
    details.tests { position: fixed; bottom: 8px; right: 8px; max-width: 360px; background: #0f1318; border: 1px solid #26303b; border-radius: .5rem; padding: .5rem .75rem; color: #cbd5e1; box-shadow: 0 10px 20px rgba(0,0,0,.4); }
    details.tests summary { cursor: pointer; }
    .test-pass { color: #22c55e; }
    .test-fail { color: #ef4444; }
  </style>
</head>
<body>
  <div class="app">
    <div class="controls">
      <h1>Orienteering Races</h1>
      <span class="pill" id="status">Finding latest data…</span>
      <div class="slider-wrap">
        <div id="slider"></div>
        <div class="date-labels">
          <span id="startLabel">—</span>
          <span id="endLabel">—</span>
        </div>
      </div>
      <div class="count"><span id="visibleCount">0</span>/<span id="totalCount">0</span></div>
    </div>
    <div id="map"></div>
  </div>

  <!-- Minimal tests visible on demand -->
  <details class="tests">
    <summary>Diagnostics & Tests</summary>
    <ul id="testResults" style="margin: .25rem 0 .25rem 1rem;"></ul>
  </details>

  <script>
    // ---- Config ----
    const OWNER = 'novotny1akub';
    const REPO = 'obcicd';
    const PATH = 'data';
    const API_URL = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${PATH}`;

    // ---- Helpers ----
    const parseDMY = (s) => {
      // Accepts formats like 01.10.2025 or 1.10.2025 or 2025-10-01
      if (!s) return null;
      const iso = /^\d{4}-\d{2}-\d{2}$/;
      if (iso.test(s)) return new Date(s + "T00:00:00");
      const m = s.match(/^(\d{1,2})[.\/-](\d{1,2})[.\/-](\d{2,4})$/);
      if (!m) return null;
      const d = parseInt(m[1], 10), mo = parseInt(m[2], 10) - 1, y = parseInt(m[3].length === 2 ? (2000 + parseInt(m[3], 10)) : m[3], 10);
      return new Date(y, mo, d);
    };
    const fmtDate = (d) => d ? d.toLocaleDateString(undefined, {year:'numeric', month:'2-digit', day:'2-digit'}) : "";
    const toNumberDate = (d) => d ? Math.floor(d.getTime() / 86400000) : NaN; // days
    const pad2 = (n) => String(n).padStart(2,'0');
    const formatYMD = (d) => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;

    // Filename → date helpers
    const CSV_RE = /^oris_(\d{4})-(\d{2})-(\d{2})\.csv$/;
    function dateFromFilename(name){
      const m = name.match(CSV_RE);
      if (!m) return null;
      const y = +m[1], mo = +m[2]-1, d = +m[3];
      return new Date(y, mo, d);
    }

    // Create a nice simple dot marker via DivIcon
    function dotIcon() {
      return L.divIcon({ className: 'race-pin', iconSize: [14,14] });
    }

    // ---- Map Init ----
    const map = L.map('map', { zoomControl: true });
    const tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    map.setView([49.8, 15.5], 7); // Roughly Czech Republic center

    const layerGroup = L.layerGroup().addTo(map);

    // Global state for filtering
    let allRecords = []; // {date, dateNum, name, place, link, lat, lon, marker}

    function buildPopupHTML(rec) {
      // Only name, place, link as requested
      const safe = (x) => String(x ?? '').replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
      return `
        <div class="tip">
          <div class="tip-title">${safe(rec.name)}</div>
          <div class="tip-place">${safe(rec.place)}</div>
          <div class="tip-link"><a href="${safe(rec.link)}" target="_blank" rel="noopener">Open in ORIS</a></div>
        </div>`;
    }

    function makeMarker(rec) {
      const marker = L.marker([rec.lat, rec.lon], { icon: dotIcon(), keyboard: false });
      marker.bindPopup(buildPopupHTML(rec), {
        className: 'zavod-pop',
        closeButton: true,
        autoClose: false,    // keep multiple popups if desired
        closeOnClick: true   // clicking on the map closes popups
      });
      // Open popup on click
      marker.on('click', function () { this.openPopup(); });
      return marker;
    }

    function refreshMap(rangeStartNum, rangeEndNum) {
      layerGroup.clearLayers();
      let count = 0;
      for (const r of allRecords) {
        if (r.dateNum >= rangeStartNum && r.dateNum <= rangeEndNum) {
          r.marker.addTo(layerGroup);
          count++;
        }
      }
      document.getElementById('visibleCount').textContent = count;
    }

    function initSlider(minNum, maxNum) {
      const slider = document.getElementById('slider');
      noUiSlider.create(slider, {
        start: [minNum, maxNum],
        connect: true,
        step: 1,
        range: { min: minNum, max: maxNum },
        behaviour: 'drag-tap',
      });
      const startLabel = document.getElementById('startLabel');
      const endLabel = document.getElementById('endLabel');

      slider.noUiSlider.on('update', (values) => {
        const [a, b] = values.map(v => Math.round(+v));
        const d1 = new Date(a * 86400000);
        const d2 = new Date(b * 86400000);
        startLabel.textContent = fmtDate(d1);
        endLabel.textContent = fmtDate(d2);
        refreshMap(a, b);
      });

      // Trigger initial render
      const [a0, b0] = slider.noUiSlider.get().map(v => Math.round(+v));
      refreshMap(a0, b0);
    }

    function fitToVisible() {
      // If there are visible markers in layerGroup, fit bounds
      const bounds = L.latLngBounds();
      layerGroup.eachLayer(layer => bounds.extend(layer.getLatLng()));
      if (bounds.isValid()) map.fitBounds(bounds.pad(0.15));
    }

    async function findLatestCsvUrl(){
      // Primary: GitHub Contents API
      try {
        const r = await fetch(API_URL, { headers: { 'Accept': 'application/vnd.github+json' }, cache: 'no-store' });
        if (!r.ok) throw new Error('API listing failed: ' + r.status);
        const items = await r.json();
        const files = items.filter(it => it && it.type === 'file' && CSV_RE.test(it.name));
        if (!files.length) throw new Error('No matching CSV files found');
        files.sort((a,b) => a.name.localeCompare(b.name)); // yyyy-mm-dd sorts lexicographically
        const latest = files[files.length-1];
        const dateStr = latest.name.match(CSV_RE).slice(1,4).join('-');
        return { url: latest.download_url || `https://raw.githubusercontent.com/${OWNER}/${REPO}/main/${PATH}/${latest.name}` , dateStr };
      } catch (apiErr) {
        console.warn('GitHub API failed, falling back to probe by date…', apiErr);
        // Fallback: probe last ~35 days on raw
        const today = new Date();
        for (let i=0; i<35; i++) {
          const d = new Date(today.getFullYear(), today.getMonth(), today.getDate()-i);
          const ds = formatYMD(d);
          const url = `https://raw.githubusercontent.com/${OWNER}/${REPO}/main/${PATH}/oris_${ds}.csv`;
          try {
            const head = await fetch(url, { method: 'HEAD', cache: 'no-store' });
            if (head.ok) return { url, dateStr: ds };
          } catch (e) {/* ignore and continue */}
        }
        throw new Error('Could not locate a recent CSV');
      }
    }

    // ---- Load CSV and render ----
    (async function load() {
      try {
        const statusEl = document.getElementById('status');
        statusEl.textContent = 'Finding latest data…';
        const latest = await findLatestCsvUrl();
        statusEl.textContent = `Loading ${latest.dateStr}…`;

        const resp = await fetch(latest.url, { cache: 'no-store' });
        if (!resp.ok) throw new Error('Failed to fetch CSV: ' + resp.status);
        const csvText = await resp.text();
        statusEl.textContent = 'Parsing…';

        const parsed = Papa.parse(csvText, { header: true, dynamicTyping: false, skipEmptyLines: true });
        if (parsed.errors && parsed.errors.length) {
          console.warn(parsed.errors);
        }

        const rows = parsed.data;
        const recs = [];
        for (const row of rows) {
          const dateRaw = row.datum || row.date || row.Date || '';
          const date = parseDMY(String(dateRaw).trim());
          const gps = (row.gps_zavod || row.gps || '').toString();
          const [latRaw, lonRaw] = gps.split(',').map(s => (s||'').trim());
          const lat = parseFloat(latRaw);
          const lon = parseFloat(lonRaw);
          const name = row.zavod_nazev || row.nazev || row.name || '';
          const place = row.misto_konani || row.misto || row.place || '';
          const link = row.url || row.link || '';

          if (!date || isNaN(lat) || isNaN(lon)) continue;

          const rec = {
            date,
            dateNum: toNumberDate(date),
            name, place, link, lat, lon,
          };
          rec.marker = makeMarker(rec);
          recs.push(rec);
        }

        allRecords = recs.sort((a,b) => a.date - b.date);
        document.getElementById('totalCount').textContent = allRecords.length;
        statusEl.textContent = `Ready – latest file: ${latest.dateStr}`;

        if (!allRecords.length) {
          statusEl.textContent = 'No records with valid coordinates.';
          return;
        }

        // Initialize slider with min/max dates
        const minNum = allRecords[0].dateNum;
        const maxNum = allRecords[allRecords.length - 1].dateNum;
        initSlider(minNum, maxNum);
        fitToVisible();

      } catch (err) {
        console.error(err);
        document.getElementById('status').textContent = 'Error loading data';
      }
    })();

    // ---- Lightweight runtime tests ----
    (function runTests(){
      const resultsEl = document.getElementById('testResults');
      function add(name, pass, detail=""){
        const li = document.createElement('li');
        li.className = pass ? 'test-pass' : 'test-fail';
        li.textContent = `${pass ? '✔' : '✖'} ${name}${detail ? ' – ' + detail : ''}`;
        resultsEl.appendChild(li);
      }
      try { // Date parsing tests
        const d1 = parseDMY('01.10.2025');
        add('parseDMY dd.mm.yyyy', d1 && d1.getFullYear()===2025 && (d1.getMonth()+1)===10 && d1.getDate()===1);
        const d2 = parseDMY('2025-10-01');
        add('parseDMY ISO yyyy-mm-dd', d2 && d2.getFullYear()===2025 && (d2.getMonth()+1)===10 && d2.getDate()===1);
        const d3 = parseDMY('1.1.25');
        add('parseDMY dd.m.yy → 2025', d3 && d3.getFullYear()===2025 && (d3.getMonth()+1)===1 && d3.getDate()===1);
        add('toNumberDate monotonic', toNumberDate(d1) < toNumberDate(new Date(2025,9,2)));
      } catch(e){ add('Date parsing suite', false, e.message); }

      // New tests: filename → date and latest selection
      try {
        add('dateFromFilename valid', formatYMD(dateFromFilename('oris_2025-10-02.csv')) === '2025-10-02');
        add('dateFromFilename invalid → null', dateFromFilename('foo.csv') === null);
        const names = ['oris_2025-09-30.csv','oris_2025-10-01.csv','oris_2025-09-29.csv'];
        const latest = names.sort().pop(); // lexicographic works for yyyy-mm-dd
        add('lexicographic latest is correct', latest === 'oris_2025-10-01.csv');
      } catch(e){ add('Filename/date suite', false, e.message); }

      try { // Marker popup wiring
        const rec = { name:'Test Event', place:'Somewhere', link:'https://example.com', lat:50, lon:14 };
        const m = makeMarker(rec);
        add('Marker has popup', !!m.getPopup());
      } catch(e){ add('Marker popup suite', false, e.message); }
    })();
  </script>
</body>
</html>