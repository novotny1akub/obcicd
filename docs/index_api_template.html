<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orienteering Events - AG Grid</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            padding: 0;
            margin: 0;
            background-color: #1e1e1e;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            width: 100%;
            height: 100vh;
            margin: 0;
            background: #1e1e1e;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        
        #myGrid {
            flex: 1;
            width: 100%;
            min-height: 0;
        }
        
        /* Remove padding from map column cells to fill entire cell */
        .ag-theme-alpine-dark .ag-cell[col-id*="Map"],
        .ag-theme-alpine-dark .ag-cell[col-id*="Map"] > div {
            padding: 0 !important;
            margin: 0 !important;
            overflow: visible;
        }
        
        /* Style for race name links */
        .ag-theme-alpine-dark .ag-cell a {
            color: #64b5f6;
            text-decoration: none;
        }
        
        .ag-theme-alpine-dark .ag-cell a:hover {
            color: #90caf9;
            text-decoration: underline;
        }
        
        /* Entries tooltip styles */
        .entries-tooltip {
            display: none;
            position: fixed;
            z-index: 10000;
            background: white;
            border: 2px solid #666;
            border-radius: 4px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            min-width: 400px;
            max-width: 600px;
            max-height: 400px;
            overflow: auto;
            pointer-events: auto;
        }
        
        .entries-tooltip table {
            border-collapse: collapse;
            width: 100%;
            font-size: 12px;
        }
        
        .entries-tooltip th {
            background: #f5f5f5;
            border-bottom: 2px solid #ddd;
            padding: 6px 8px;
            text-align: left;
            border: 1px solid #ddd;
        }
        
        .entries-tooltip td {
            padding: 4px 8px;
            border: 1px solid #ddd;
        }
        
        .entries-tooltip td:last-child {
            text-align: right;
        }
        
        .entries-cell-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .entries-count {
            cursor: pointer;
            text-decoration: underline;
            color: #64b5f6;
        }
        
        .entries-count:hover {
            color: #90caf9;
        }
        
        /* Custom tooltip styling */
        .custom-tooltip {
            background: #2d2d2d;
            border: 2px solid #555;
            border-radius: 4px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            min-width: 400px;
            max-width: 600px;
            max-height: 400px;
            overflow: auto;
            color: #e0e0e0;
        }
        
        .custom-tooltip table {
            border-collapse: collapse;
            width: 100%;
            font-size: 12px;
            margin-top: 8px;
        }
        
        .custom-tooltip th {
            background: #3d3d3d;
            border-bottom: 2px solid #555;
            padding: 6px 8px;
            text-align: left;
            border: 1px solid #555;
            color: #e0e0e0;
        }
        
        .custom-tooltip td {
            padding: 4px 8px;
            border: 1px solid #555;
            color: #e0e0e0;
        }
        
        .custom-tooltip td:last-child {
            text-align: right;
        }
        
        /* Modal overlay for mobile/desktop */
        .data-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .data-modal.show {
            display: flex;
        }
        
        .data-modal-content {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            max-width: 90%;
            max-height: 80vh;
            overflow: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            position: relative;
            color: #e0e0e0;
        }
        
        .data-modal-content h3 {
            color: #e0e0e0;
        }
        
        .data-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #999;
            line-height: 1;
        }
        
        .data-modal-close:hover {
            color: #e0e0e0;
        }
        
        .data-modal-content table {
            border-collapse: collapse;
            width: 100%;
            font-size: 14px;
            margin-top: 10px;
        }
        
        .data-modal-content th {
            background: #3d3d3d;
            border-bottom: 2px solid #555;
            padding: 10px 12px;
            text-align: left;
            border: 1px solid #555;
            color: #e0e0e0;
        }
        
        .data-modal-content td {
            padding: 8px 12px;
            border: 1px solid #555;
            color: #e0e0e0;
        }
        
        .data-modal-content td:last-child {
            text-align: right;
        }
        
        /* Mobile responsive font sizes */
        @media (max-width: 768px) {
            body {
                font-size: 12px;
            }
            
            /* Smaller font in grid cells */
            .ag-theme-alpine-dark .ag-cell {
                font-size: 11px;
            }
            
            /* Smaller column headers */
            .ag-theme-alpine-dark .ag-header-cell-text {
                font-size: 11px;
            }
            
            /* Smaller modal content */
            .data-modal-content {
                padding: 15px;
                font-size: 12px;
            }
            
            .data-modal-content h3 {
                font-size: 16px;
            }
            
            .data-modal-content table {
                font-size: 11px;
            }
            
            .data-modal-content th,
            .data-modal-content td {
                padding: 6px 8px;
            }
        }
        
        @media (max-width: 480px) {
            body {
                font-size: 11px;
            }
            
            .ag-theme-alpine-dark .ag-cell {
                font-size: 10px;
            }
            
            .ag-theme-alpine-dark .ag-header-cell-text {
                font-size: 10px;
            }
            
            .data-modal-content {
                padding: 12px;
                font-size: 11px;
            }
            
            .data-modal-content h3 {
                font-size: 15px;
            }
            
            .data-modal-content table {
                font-size: 10px;
            }
            
            .data-modal-content th,
            .data-modal-content td {
                padding: 4px 6px;
            }
        }
        
    </style>
    <!-- AG Grid Enterprise CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@31.0.0/styles/ag-grid.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@31.0.0/styles/ag-theme-alpine-dark.css">
</head>
<body>
    <div class="container">
        <div id="myGrid" class="ag-theme-alpine-dark"></div>
    </div>

    <!-- AG Grid Enterprise JS -->
    <script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@31.0.0/dist/ag-grid-enterprise.min.js"></script>
    
    <script>
        // Custom tooltip component for HTML rendering
        class CustomHtmlTooltip {
            init(params) {
                this.eGui = document.createElement('div');
                this.eGui.className = 'custom-tooltip';
                this.eGui.innerHTML = params.value || '';
            }
            
            getGui() {
                return this.eGui;
            }
        }
        
        // Modal overlay for displaying data tables
        let dataModal = null;
        
        function showDataModal(title, htmlContent) {
            // Create modal if it doesn't exist
            if (!dataModal) {
                dataModal = document.createElement('div');
                dataModal.className = 'data-modal';
                dataModal.innerHTML = `
                    <div class="data-modal-content">
                        <span class="data-modal-close">&times;</span>
                        <div class="data-modal-body"></div>
                    </div>
                `;
                document.body.appendChild(dataModal);
                
                // Close on X click
                dataModal.querySelector('.data-modal-close').addEventListener('click', hideDataModal);
                
                // Close on background click
                dataModal.addEventListener('click', (e) => {
                    if (e.target === dataModal) {
                        hideDataModal();
                    }
                });
            }
            
            // Update content
            const body = dataModal.querySelector('.data-modal-body');
            body.innerHTML = `<h3 style="margin: 0 0 15px 0; color: #333;">${title}</h3>${htmlContent}`;
            
            // Show modal
            dataModal.classList.add('show');
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
        }
        
        function hideDataModal() {
            if (dataModal) {
                dataModal.classList.remove('show');
                document.body.style.overflow = '';
            }
        }
        
        // Cache for complete Czech Republic SVG (all paths)
        let czSvgData = null;
        
        // Fetch the complete Czech Republic SVG without simplification
        async function loadCzechOutline() {
            try {
                const response = await fetch('https://upload.wikimedia.org/wikipedia/commons/0/0e/Cesko-kraje.svg');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const svgText = await response.text();
                
                // Parse SVG XML
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                
                // Check for parsing errors
                const parserError = svgDoc.querySelector('parsererror');
                if (parserError) {
                    throw new Error('SVG parsing error');
                }
                
                const svgElement = svgDoc.documentElement;
                
                // Get viewBox for coordinate system
                const viewBox = svgElement.getAttribute('viewBox');
                let viewBoxValues = [0, 0, 1000, 600]; // Default
                if (viewBox) {
                    viewBoxValues = viewBox.split(/\s+/).map(Number).filter(v => !isNaN(v));
                    if (viewBoxValues.length !== 4) {
                        // Try getting width/height as fallback
                        const width = parseFloat(svgElement.getAttribute('width')) || 1000;
                        const height = parseFloat(svgElement.getAttribute('height')) || 600;
                        viewBoxValues = [0, 0, width, height];
                    }
                }
                
                // Collect ALL paths from the SVG (excluding only text/labels)
                const allPaths = [];
                const paths = svgElement.querySelectorAll('path');
                
                paths.forEach(path => {
                    const id = path.getAttribute('id') || '';
                    const d = path.getAttribute('d') || '';
                    
                    // Only skip text/label elements, keep everything else
                    const isLabel = id.toLowerCase().includes('label') ||
                                  id.toLowerCase().includes('text');
                    
                    if (!isLabel && d && d.length > 0) {
                        allPaths.push({
                            d: d,
                            id: id,
                            fill: path.getAttribute('fill') || null,
                            stroke: path.getAttribute('stroke') || null,
                            strokeWidth: path.getAttribute('stroke-width') || null,
                            class: path.getAttribute('class') || null
                        });
                    }
                });
                
                if (allPaths.length > 0) {
                    czSvgData = {
                        paths: allPaths,
                        viewBox: viewBoxValues
                    };
                    console.log('Loaded complete Czech SVG successfully', { 
                        pathCount: allPaths.length, 
                        viewBox: viewBoxValues
                    });
                } else {
                    console.warn('No paths found in SVG');
                }
            } catch (error) {
                console.error('Could not load SVG from Wikimedia, using simplified path:', error);
            }
        }
        
        // Embedded data from data.json
        const data = __ORIS_DATA__;        
        // Process data immediately
        // Flatten nested objects for better display
        const processedData = data.map(row => {
            // Convert nested arrays to readable strings
            const entries = row.our_future_entries || {};
            const startLists = row.our_future_start_lists || {};
            
            // Count entries and format if available
            const entriesCount = Array.isArray(entries) ? entries.length : 
                               (typeof entries === 'object' && Object.keys(entries).length > 0) ? Object.keys(entries).length : 0;
            const startListsCount = Array.isArray(startLists) ? startLists.length : 
                                  (typeof startLists === 'object' && Object.keys(startLists).length > 0) ? Object.keys(startLists).length : 0;
            
            return {
                ...row,
                our_future_entries_count: entriesCount,
                our_future_start_lists_count: startListsCount,
                our_future_entries_raw: entries, // Keep original for tooltip
                our_future_start_lists_raw: startLists, // Keep original for tooltip
                our_future_entries: JSON.stringify(entries),
                our_future_start_lists: JSON.stringify(startLists)
            };
        });

        // Column definitions
        const columnDefs = [
            { field: 'event_id', headerName: 'Event ID', width: 100, pinned: 'left', filter: 'agNumberColumnFilter', hide: true },
            { 
                field: 'date', 
                headerName: 'Date', 
                width: 120, 
                filter: 'agDateColumnFilter',
                filterParams: {
                    comparator: function(filterLocalDateAtMidnight, cellValue) {
                        if (cellValue == null) return -1;
                        
                        // Parse string date "YYYY-MM-DD"
                        const dateParts = cellValue.split('-');
                        if (dateParts.length !== 3) return -1;
                        
                        const year = Number(dateParts[0]);
                        const month = Number(dateParts[1]) - 1; // JS months are 0-based
                        const day = Number(dateParts[2]);
                        
                        const cellDate = new Date(year, month, day);
                        
                        // Compare dates (ignoring time)
                        if (filterLocalDateAtMidnight.getTime() === cellDate.getTime()) {
                            return 0;
                        }
                        
                        if (cellDate < filterLocalDateAtMidnight) {
                            return -1;
                        }
                        
                        if (cellDate > filterLocalDateAtMidnight) {
                            return 1;
                        }
                        
                        return 0;
                    }
                }
            },
            { field: 'date_label', headerName: 'Date Label', width: 180, filter: 'agTextColumnFilter' },
            { 
                field: 'name', 
                headerName: 'Name', 
                width: 200, 
                filter: 'agTextColumnFilter',
                cellRenderer: function(params) {
                    const eventId = params.data.event_id;
                    const name = params.value || '';
                    if (eventId) {
                        const url = `https://oris.ceskyorientak.cz/Zavod?id=${eventId}`;
                        // Escape HTML in name to prevent XSS
                        const escapedName = name.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                        return `<a href="${url}" target="_blank">${escapedName}</a>`;
                    }
                    return name;
                }
            },
            { field: 'place', headerName: 'Place', width: 180, filter: 'agTextColumnFilter' },
            { field: 'cst_entries', headerName: 'CST Entries', width: 100, filter: 'agNumberColumnFilter', hide: true },
            { 
                field: 'our_future_entries_count', 
                headerName: 'Our Entries', 
                width: 115, 
                filter: 'agNumberColumnFilter',
                cellRenderer: function(params) {
                    const count = params.value || 0;
                    
                    if (count === 0) {
                        return '<span style="color: #999;">0</span>';
                    }
                    
                    return `<span class="entries-count" style="cursor: pointer; -webkit-tap-highlight-color: transparent; user-select: none;">${count}</span>`;
                },
                tooltipValueGetter: function(params) {
                    const entries = params.data.our_future_entries_raw;
                    const count = params.value || 0;
                    
                    if (count === 0 || !entries || !Array.isArray(entries) || entries.length === 0) {
                        return null;
                    }
                    
                    // Build HTML table for tooltip (for desktop hover)
                    let tableRows = '';
                    entries.forEach(entry => {
                        const classDesc = (entry.ClassDesc || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        const name = (entry.Name || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        const si = (entry.SI || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        const fee = (entry.Fee || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        tableRows += `<tr><td>${classDesc}</td><td>${name}</td><td>${si}</td><td>${fee}</td></tr>`;
                    });
                    
                    return `<strong>Entries (${count})</strong><table><thead><tr><th>Class</th><th>Name</th><th>SI</th><th>Fee</th></tr></thead><tbody>${tableRows}</tbody></table>`;
                },
                tooltipComponent: CustomHtmlTooltip,
                tooltipInteraction: true
            },
            { 
                field: 'our_future_start_lists_count', 
                headerName: 'Our Start Lists', 
                width: 135, 
                filter: 'agNumberColumnFilter',
                cellRenderer: function(params) {
                    const count = params.value || 0;
                    
                    if (count === 0) {
                        return '<span style="color: #999;">0</span>';
                    }
                    
                    return `<span class="entries-count" style="cursor: pointer; -webkit-tap-highlight-color: transparent; user-select: none;">${count}</span>`;
                },
                tooltipValueGetter: function(params) {
                    const startLists = params.data.our_future_start_lists_raw;
                    const count = params.value || 0;
                    
                    if (count === 0 || !startLists || !Array.isArray(startLists) || startLists.length === 0) {
                        return null;
                    }
                    
                    // Build HTML table for tooltip (for desktop hover)
                    let tableRows = '';
                    startLists.forEach(startList => {
                        const classDesc = (startList.ClassDesc || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        const name = (startList.Name || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        // Extract only the time portion (format: "YYYY-MM-DD HH:MM:SS" -> "HH:MM")
                        let startTime = startList.StartTime || '';
                        if (startTime && startTime.includes(' ')) {
                            startTime = startTime.split(' ')[1];
                        }
                        // Remove seconds (format: "HH:MM:SS" -> "HH:MM")
                        if (startTime && startTime.includes(':')) {
                            const timeParts = startTime.split(':');
                            if (timeParts.length >= 2) {
                                startTime = timeParts[0] + ':' + timeParts[1];
                            }
                        }
                        startTime = startTime.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        tableRows += `<tr><td>${classDesc}</td><td>${name}</td><td>${startTime}</td></tr>`;
                    });
                    
                    return `<strong>Start Lists (${count})</strong><table><thead><tr><th>Class</th><th>Name</th><th>Start Time</th></tr></thead><tbody>${tableRows}</tbody></table>`;
                },
                tooltipComponent: CustomHtmlTooltip,
                tooltipInteraction: true
            },
            { 
                headerName: 'Map', 
                width: 120,
                cellStyle: { padding: '0px', margin: '0px' },
                cellRenderer: function(params) {
                    const lat = params.data.gps_lat;
                    const lon = params.data.gps_lon;
                    
                    if (!lat || !lon || lat === 0 || lon === 0) {
                        return '';
                    }
                    
                    // Czech Republic geographic boundaries (from Wikimedia Commons data)
                    const minLat = 48.3;
                    const maxLat = 51.3;
                    const minLon = 11.8;
                    const maxLon = 19.2;
                    
                    // SVG dimensions - fill entire cell (accounting for row height of 55px)
                    const svgWidth = 120;
                    const svgHeight = 55;
                    const mapWidth = svgWidth;
                    const mapHeight = svgHeight;
                    
                    // Helper function to convert lat/lon to SVG coordinates
                    const latLonToSvg = (lonCoord, latCoord) => {
                        const x = ((lonCoord - minLon) / (maxLon - minLon)) * mapWidth;
                        const y = ((maxLat - latCoord) / (maxLat - minLat)) * mapHeight;
                        return { x, y };
                    };
                    
                    // Scale GPS coordinates to SVG space (accurate mapping)
                    const point = latLonToSvg(lon, lat);
                    const x = point.x;
                    const y = point.y;
                    
                    // Use the complete SVG if available, otherwise fall back to simplified path
                    let allPathsHtml = '';
                    let pathTransform = '';
                    
                    if (czSvgData && czSvgData.paths && czSvgData.paths.length > 0) {
                        // Use the complete SVG from Wikimedia Commons (all paths, no simplification)
                        const origViewBox = czSvgData.viewBox;
                        if (origViewBox && origViewBox.length === 4) {
                            const origMinX = origViewBox[0];
                            const origMinY = origViewBox[1];
                            const origWidth = origViewBox[2] - origViewBox[0];
                            const origHeight = origViewBox[3] - origViewBox[1];
                            
                            if (origWidth > 0 && origHeight > 0) {
                                // Map original SVG coordinates to our GPS-based coordinate system
                                // Scale and translate to match our coordinate mapping
                                const scaleX = mapWidth / origWidth;
                                const scaleY = mapHeight / origHeight;
                                
                                // Translate to account for origin offset (no padding - fill entire cell)
                                const translateX = -(origMinX * scaleX);
                                const translateY = -(origMinY * scaleY);
                                
                                pathTransform = `translate(${translateX}, ${translateY}) scale(${scaleX}, ${scaleY})`;
                                
                                // Build HTML for all paths, preserving original attributes where possible
                                allPathsHtml = czSvgData.paths.map(pathInfo => {
                                    // Use original attributes or defaults
                                    const fill = pathInfo.fill || '#f5f5f5';
                                    const stroke = pathInfo.stroke || '#666';
                                    const strokeWidth = pathInfo.strokeWidth || '0.8';
                                    
                                    return `<path d="${pathInfo.d}" fill="${fill}" stroke="${stroke}" stroke-width="${strokeWidth}"/>`;
                                }).join('');
                            }
                        }
                    }
                    
                    // Fallback: simplified path if SVG not loaded or transform failed
                    if (!allPathsHtml || allPathsHtml.length === 0) {
                        const boundaryPoints = [
                            { lon: 12.1, lat: 50.2 },
                            { lon: 12.1, lat: 49.0 },
                            { lon: 13.8, lat: 48.5 },
                            { lon: 16.0, lat: 48.6 },
                            { lon: 18.8, lat: 49.0 },
                            { lon: 19.0, lat: 50.0 },
                            { lon: 18.5, lat: 50.8 },
                            { lon: 15.5, lat: 51.0 },
                            { lon: 12.1, lat: 50.2 }
                        ];
                        
                        let pathData = '';
                        boundaryPoints.forEach((pt, idx) => {
                            const svgPt = latLonToSvg(pt.lon, pt.lat);
                            if (idx === 0) {
                                pathData += `M ${svgPt.x} ${svgPt.y} `;
                            } else {
                                pathData += `L ${svgPt.x} ${svgPt.y} `;
                            }
                        });
                        pathData += 'Z';
                        allPathsHtml = `<path d="${pathData}" fill="#f5f5f5" stroke="#666" stroke-width="0.8"/>`;
                        pathTransform = ''; // No transform needed for fallback
                    }
                    
                    return `
                        <div style="width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;">
                            <svg width="${svgWidth}" height="${svgHeight}" style="display: block; width: 100%; height: 100%; margin: 0; padding: 0;" viewBox="0 0 ${svgWidth} ${svgHeight}" preserveAspectRatio="xMidYMid meet">
                                ${pathTransform ? `<g transform="${pathTransform}">` : ''}
                                    ${allPathsHtml}
                                ${pathTransform ? '</g>' : ''}
                                <circle cx="${x}" cy="${y}" r="2.5" fill="#d32f2f" stroke="#fff" stroke-width="1.2"/>
                            </svg>
                        </div>
                    `;
                },
                sortable: false,
                filter: false,
                enableMenu: true,
                menuTabs: ['generalMenuTab', 'columnsMenuTab']
            },
            { field: 'region', headerName: 'Region', width: 100, filter: 'agTextColumnFilter', hide: true },
            { field: 'sport', headerName: 'Sport', width: 120, filter: 'agTextColumnFilter' },
            { field: 'discipline', headerName: 'Discipline', width: 150, filter: 'agTextColumnFilter', hide: true },
            { field: 'level', headerName: 'Level', width: 200, filter: 'agTextColumnFilter', hide: true },
            { field: 'status', headerName: 'Status', width: 100, filter: 'agTextColumnFilter', hide: true },
            { field: 'org1_abbr', headerName: 'Org1', width: 100, filter: 'agTextColumnFilter', hide: true },
            { field: 'org1_name', headerName: 'Organization', width: 200, filter: 'agTextColumnFilter', hide: true },
            { field: 'org2_abbr', headerName: 'Org2', width: 100, filter: 'agTextColumnFilter', hide: true },
            { field: 'org2_name', headerName: 'Org2 Name', width: 200, filter: 'agTextColumnFilter', hide: true },
            { field: 'gps_lat', headerName: 'Latitude', width: 120, filter: 'agNumberColumnFilter', hide: true },
            { field: 'gps_lon', headerName: 'Longitude', width: 120, filter: 'agNumberColumnFilter', hide: true }
        ];

        // Grid options
        const gridOptions = {
            columnDefs: columnDefs,
            rowData: processedData,
            rowHeight: 55,
            defaultColDef: {
                sortable: true,
                resizable: true,
                filter: true,
                menuTabs: ['filterMenuTab', 'generalMenuTab', 'columnsMenuTab'],
                suppressMenuHide: false,
                enableMenu: true
            },
            pagination: false,
            animateRows: true,
            enableRangeSelection: true,
            rowSelection: 'multiple',
            suppressMenuHide: false,
            multiSortKey: 'ctrl',
            unSortIcon: true,
            suppressMultiSort: false,
            sideBar: {
                toolPanels: [
                    {
                        id: 'filters',
                        labelDefault: 'Filters',
                        labelKey: 'filters',
                        iconKey: 'filter',
                        toolPanel: 'agFiltersToolPanel',
                        toolPanelParams: {
                            suppressExpandAll: false,
                            suppressFilterSearch: false
                        }
                    },
                    {
                        id: 'columns',
                        labelDefault: 'Columns',
                        labelKey: 'columns',
                        iconKey: 'columns',
                        toolPanel: 'agColumnsToolPanel',
                        toolPanelParams: {
                            suppressRowGroups: true,
                            suppressValues: true,
                            suppressPivots: true,
                            suppressPivotMode: true,
                            suppressColumnFilter: false,
                            suppressColumnSelectAll: false,
                            suppressColumnExpandAll: false
                        }
                    }
                ],
                defaultToolPanel: 'columns',
                hiddenByDefault: false
            },
            onGridReady: function(params) {
                // Grid is ready, store API reference
                gridOptions.api = params.api;
                // Collapse the sidebar on load
                params.api.closeToolPanel();
                // Auto-size the entries and start lists columns to fit their headers
                params.api.autoSizeColumns(['our_future_entries_count', 'our_future_start_lists_count']);
                
                // Check if any row has future entries > 0
                const hasFutureEntries = processedData.some(r => r.our_future_entries_count > 0);
                
                // Only apply filter if there are actually future entries to show
                if (hasFutureEntries) {
                    // Filter rows where 'Our Entries' is greater than 0
                    params.api.setFilterModel({
                        our_future_entries_count: {
                            filterType: 'number',
                            type: 'greaterThan',
                            filter: 0
                        }
                    });
                }
            },
            onCellClicked: function(params) {
                // Handle clicks on Our Entries column
                if (params.column && params.column.colId === 'our_future_entries_count') {
                    const entries = params.data.our_future_entries_raw;
                    const count = params.data.our_future_entries_count || 0;
                    
                    if (count > 0 && entries && Array.isArray(entries) && entries.length > 0) {
                        // Build table HTML
                        let tableRows = '';
                        entries.forEach(entry => {
                            const classDesc = (entry.ClassDesc || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            const name = (entry.Name || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            const si = (entry.SI || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            const fee = (entry.Fee || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            tableRows += `<tr><td>${classDesc}</td><td>${name}</td><td>${si}</td><td>${fee}</td></tr>`;
                        });
                        
                        const tableHtml = `<table><thead><tr><th>Class</th><th>Name</th><th>SI</th><th>Fee</th></tr></thead><tbody>${tableRows}</tbody></table>`;
                        showDataModal(`Entries (${count})`, tableHtml);
                    }
                }
                
                // Handle clicks on Our Start Lists column
                if (params.column && params.column.colId === 'our_future_start_lists_count') {
                    const startLists = params.data.our_future_start_lists_raw;
                    const count = params.data.our_future_start_lists_count || 0;
                    
                    if (count > 0 && startLists && Array.isArray(startLists) && startLists.length > 0) {
                        // Build table HTML
                        let tableRows = '';
                        startLists.forEach(startList => {
                            const classDesc = (startList.ClassDesc || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            const name = (startList.Name || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            // Extract only the time portion (format: "YYYY-MM-DD HH:MM:SS" -> "HH:MM")
                            let startTime = startList.StartTime || '';
                            if (startTime && startTime.includes(' ')) {
                                startTime = startTime.split(' ')[1];
                            }
                            // Remove seconds (format: "HH:MM:SS" -> "HH:MM")
                            if (startTime && startTime.includes(':')) {
                                const timeParts = startTime.split(':');
                                if (timeParts.length >= 2) {
                                    startTime = timeParts[0] + ':' + timeParts[1];
                                }
                            }
                            startTime = startTime.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            tableRows += `<tr><td>${classDesc}</td><td>${name}</td><td>${startTime}</td></tr>`;
                        });
                        
                        const tableHtml = `<table><thead><tr><th>Class</th><th>Name</th><th>Start Time</th></tr></thead><tbody>${tableRows}</tbody></table>`;
                        showDataModal(`Start Lists (${count})`, tableHtml);
                    }
                }
            }
        };

        // Initialize the grid and load SVG
        const gridDiv = document.querySelector('#myGrid');
        new agGrid.Grid(gridDiv, gridOptions);
        
        // Load the SVG in the background and refresh when ready
        loadCzechOutline().then(() => {
            console.log('SVG loaded, refreshing grid cells...');
            if (czSvgData && gridOptions.api) {
                try {
                    gridOptions.api.refreshCells({ force: true });
                    console.log('Grid refreshed with complete SVG');
                } catch (e) {
                    console.warn('Refresh failed, using data update:', e);
                    // Alternative: update data to force refresh
                    gridOptions.api.setGridOption('rowData', [...processedData]);
                }
            } else {
                console.warn('Cannot refresh: API or SVG data not available', {
                    hasApi: !!gridOptions.api,
                    hasSvgData: !!czSvgData
                });
            }
        });
    </script>
</body>
</html>
